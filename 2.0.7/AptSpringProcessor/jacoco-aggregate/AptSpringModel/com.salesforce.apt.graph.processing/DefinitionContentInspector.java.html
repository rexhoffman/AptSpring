<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../../jacoco-resources/report.gif" type="image/gif"/><title>DefinitionContentInspector.java</title><link rel="stylesheet" href="../../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../../index.html" class="el_report">AptSpringProcessor</a> &gt; <a href="../index.html" class="el_bundle">AptSpringModel</a> &gt; <a href="index.source.html" class="el_package">com.salesforce.apt.graph.processing</a> &gt; <span class="el_source">DefinitionContentInspector.java</span></div><h1>DefinitionContentInspector.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2017, Salesforce.com, Inc
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the &lt;organization&gt; nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.salesforce.apt.graph.processing;

import java.util.AbstractMap.SimpleEntry;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.function.Consumer;
import java.util.stream.Collectors;
import java.util.stream.Stream;

import org.jgrapht.Graph;
import org.jgrapht.alg.cycle.SzwarcfiterLauerSimpleCycles;
import org.jgrapht.graph.DefaultDirectedGraph;
import org.jgrapht.graph.DefaultEdge;

import com.salesforce.apt.graph.model.AbstractModel;
import com.salesforce.apt.graph.model.BaseInstanceModel;
import com.salesforce.apt.graph.model.DefinitionModel;
import com.salesforce.apt.graph.model.ExpectedModel;
import com.salesforce.apt.graph.model.InstanceDependencyModel;
import com.salesforce.apt.graph.model.InstanceModel;
import com.salesforce.apt.graph.model.errors.ErrorModel;
import com.salesforce.apt.graph.model.errors.ErrorType;
import com.salesforce.apt.graph.model.storage.DefinitionModelStore;
import com.salesforce.apt.graph.types.AssignabilityUtils;

<span class="fc" id="L58">public class DefinitionContentInspector {</span>

  public void inspectDefinitionGraph(Set&lt;DefinitionModel&gt; definitionGraphHeads,
      Consumer&lt;ErrorModel&gt; errorListener, AssignabilityUtils assignabilityUtils, DefinitionModelStore store) {
<span class="fc bfc" id="L62" title="All 2 branches covered.">    for (DefinitionModel definition : definitionGraphHeads) {</span>
<span class="fc" id="L63">      depthFirstExpectedsInspector(definition, errorListener, assignabilityUtils, store);</span>
<span class="fc" id="L64">    }</span>
<span class="fc" id="L65">  }</span>
  
  public InstanceModel getOneWithSourceElementElseAny(final Collection&lt;InstanceModel&gt; possibilities) {
<span class="nc" id="L68">    return possibilities.stream()</span>
<span class="nc" id="L69">         .filter(im -&gt; im.getSourceElement().isPresent())</span>
<span class="nc" id="L70">         .findAny().orElseGet(() -&gt; possibilities.iterator().next());</span>
  }
  
  /**
   * The the sha 256 of dependencies against the stored data.
   * 
   * @param model model who's dependencies we will inspect
   * @param store the store of all the model data (abstraction, will likely be in memory or class files)
   * @param errorListener if any shas mismatch will report here.
   * @return true if all shas match.
   */
  public boolean verifiedShas(DefinitionModel model, DefinitionModelStore store, Consumer&lt;ErrorModel&gt; errorListener) {
<span class="nc" id="L82">    boolean verified = true;</span>
<span class="nc bnc" id="L83" title="All 2 branches missed.">    for (DefinitionModel dep : model.getDependencies()) {</span>
<span class="nc bnc" id="L84" title="All 2 branches missed.">      if (!dep.getSourceElement().isPresent()  //not recompiling</span>
<span class="nc bnc" id="L85" title="All 2 branches missed.">          &amp;&amp; model.getDependencyNameToSha256().containsKey(dep.getIdentity())) { //model already has a sha256 of it</span>
<span class="nc bnc" id="L86" title="All 2 branches missed.">        if (!model.getDependencyNameToSha256().get(dep.getIdentity()).equals(dep.getSha256())) {</span>
<span class="nc" id="L87">          errorListener.accept(new ErrorModel(ErrorType.DEPENDENCY_SHA_MISMATCH,</span>
<span class="nc" id="L88">                Arrays.asList(model, dep),  Arrays.asList(model)));</span>
<span class="nc" id="L89">          verified = false;</span>
        }
      }
<span class="nc" id="L92">    }</span>
<span class="nc" id="L93">    return verified;</span>
  }
  
  
  /**
   * Verify that all expected entities are marked expected.
   * Verify that the types of provided entities satisfy all expected types....
   * &lt;p/&gt;
   * if a child record was freshly process, so too must all parent ( if the md5 has changed ).
   *  
   * @param definition the head of current tree of definitions linked by imports
   * @param errorListener registers all errors found 
   */
  private boolean depthFirstExpectedsInspector(DefinitionModel definition, Consumer&lt;ErrorModel&gt; errorListener,
      AssignabilityUtils assignabilityUtils, DefinitionModelStore store) {
<span class="fc" id="L108">    boolean errored = false;</span>
<span class="fc bfc" id="L109" title="All 2 branches covered.">    for (DefinitionModel dependency : definition.getDependencies()) {</span>
<span class="pc bpc" id="L110" title="1 of 2 branches missed.">      if (!dependency.isLockedAnalyzed()) {</span>
<span class="pc bpc" id="L111" title="2 of 4 branches missed.">        errored = depthFirstExpectedsInspector(dependency, errorListener, assignabilityUtils, store) || errored;</span>
<span class="pc bpc" id="L112" title="1 of 2 branches missed.">        if (errored) {</span>
<span class="nc" id="L113">          return true; // no need to continue.</span>
        }
      } else {
<span class="nc bnc" id="L116" title="All 2 branches missed.">        if (!verifiedShas(dependency, store, errorListener)) {</span>
<span class="nc" id="L117">          errored = true;</span>
        }
      }
<span class="fc" id="L120">    }</span>
    
<span class="pc bpc" id="L122" title="1 of 2 branches missed.">    if (errored) {</span>
<span class="nc" id="L123">      return errored;</span>
    }
    
    //check that each object has only one source ( could be the imported from a dependency, in a diamond pattern )
    //validate the expected beans are correct.
<span class="fc" id="L128">    Map&lt;String, InstanceModel&gt; resolvedInstances = ensureSingleInstanceOfEachName(definition, errorListener);</span>
    
    //short circuit if dependencies couldn't be resolved.
<span class="fc bfc" id="L131" title="All 2 branches covered.">    if (resolvedInstances == null) {</span>
<span class="fc" id="L132">      return false;</span>
    }
    
    //looks for cycles and unexpected missing entities.
<span class="fc" id="L136">    errored = detectCyclesInEntityGraph(definition, resolvedInstances, errorListener);</span>

    //check types of non-expected dependencies
<span class="fc bfc" id="L139" title="All 4 branches covered.">    errored = checkInstancesTypesInDefinition(definition, resolvedInstances, errorListener, assignabilityUtils) || errored;</span>

    //check all definitions with expected, that each instance expecting a definition can use the supplied.
<span class="fc bfc" id="L142" title="All 4 branches covered.">    errored = checkProvidedSupplyCorrectTypes(definition, resolvedInstances, errorListener, assignabilityUtils) || errored;</span>

    //prune all edged from graph that don't end in an expected

    //store computed expects with all types that must satisfied.
    
    
    
<span class="fc bfc" id="L150" title="All 2 branches covered.">    if (!errored) {</span>
      //store as provided dependencies
<span class="fc" id="L152">      definition.addAllProvidedInstances(resolvedInstances.values());</span>
<span class="fc bfc" id="L153" title="All 2 branches covered.">      for (DefinitionModel dep : definition.getDependencies()) {</span>
<span class="fc" id="L154">        definition.addDependencyNameToSha256(dep.getIdentity(), dep.getSha256());</span>
<span class="fc" id="L155">      }</span>
      //storing will lock a the definition, as will reading.
<span class="fc bfc" id="L157" title="All 2 branches covered.">      if (!store.store(definition)) {</span>
<span class="fc" id="L158">        errorListener.accept(</span>
<span class="fc" id="L159">            new ErrorModel(ErrorType.COULD_NOT_STORE, Arrays.asList(definition), Arrays.asList(definition)));</span>
      }
    }
    
<span class="fc" id="L163">    return errored;</span>
  }

  private ErrorModel errorForMismatchedExpected(final DefinitionModel definition, ExpectedModel computedExpected,
      final Map&lt;String, InstanceModel&gt; nameToEntity, AssignabilityUtils assignabilityUtils) {
    //that which is to fill all the expectedInstance references.
<span class="fc" id="L169">    InstanceModel providedInstance = nameToEntity.get(computedExpected.getIdentity());</span>
    
    //the top level definition model should have declared this an expectedBean - maybe move that error here?
<span class="fc bfc" id="L172" title="All 2 branches covered.">    if (providedInstance == null) {</span>
<span class="fc" id="L173">      return null;</span>
    }
    
    //Instances which expect to use the provided instance
<span class="fc" id="L177">    List&lt;InstanceModel&gt; mistmatchedExpectantEntities = computedExpected.getDefinitionReferenceToType().keySet().stream()</span>
<span class="fc" id="L178">        .map(name -&gt; nameToEntity.get(name))</span>
<span class="fc bfc" id="L179" title="All 2 branches covered.">        .filter(expectantInstance -&gt; !assignabilityUtils.isAssignableFrom(providedInstance, expectantInstance))</span>
<span class="fc" id="L180">        .collect(Collectors.toList());</span>
    
<span class="fc bfc" id="L182" title="All 2 branches covered.">    if (mistmatchedExpectantEntities.size() == 0) {</span>
<span class="fc" id="L183">      return null;</span>
    } else {
<span class="fc" id="L185">      List&lt;InstanceModel&gt; involved = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L186">      involved.add(providedInstance);</span>
<span class="fc" id="L187">      involved.addAll(mistmatchedExpectantEntities);</span>
<span class="fc" id="L188">      return new ErrorModel(ErrorType.UNMATCHED_TYPES, involved, Arrays.asList(definition, providedInstance));</span>
    }
  }
  
  private boolean checkProvidedSupplyCorrectTypes(final DefinitionModel definition, final Map&lt;String, InstanceModel&gt; nameToEntity,
      final Consumer&lt;ErrorModel&gt; errorListner, AssignabilityUtils assignabilityUtils) {
<span class="fc" id="L194">    List&lt;ErrorModel&gt; errors = definition.getDependencies().stream()</span>
<span class="fc" id="L195">        .flatMap(dependency -&gt; dependency.getComputedExpected().stream())</span>
<span class="fc" id="L196">        .filter(expectedModel -&gt; !definition.getExpectedDefinitions().stream()</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">            .anyMatch(ed -&gt; ed.getIdentity().equals(expectedModel.getIdentity())))</span>
<span class="fc" id="L198">        .map(em -&gt; errorForMismatchedExpected(definition, em, nameToEntity, assignabilityUtils))</span>
<span class="fc bfc" id="L199" title="All 2 branches covered.">        .filter(errorModel -&gt; errorModel != null)</span>
<span class="fc" id="L200">        .collect(Collectors.toList());</span>
<span class="fc" id="L201">    errors.stream().forEach(errorListner);</span>
<span class="fc bfc" id="L202" title="All 2 branches covered.">    return errors.size() &gt; 0;</span>
  }
  
  
  private List&lt;Entry&lt;String, InstanceModel&gt;&gt; getEntryListForNameAndAlias(InstanceModel instanceModel) {
<span class="fc" id="L207">    List&lt;Entry&lt;String, InstanceModel&gt;&gt; output = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L208">    output.add(new SimpleEntry&lt;&gt;(instanceModel.getIdentity(), instanceModel));</span>
<span class="fc bfc" id="L209" title="All 2 branches covered.">    for (String alias : instanceModel.getAliases()) {</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">      if (!alias.equals(instanceModel.getIdentity())) {</span>
<span class="fc" id="L211">        output.add(new SimpleEntry&lt;&gt;(alias, instanceModel));</span>
      }
<span class="fc" id="L213">    }</span>
<span class="fc" id="L214">    return output;</span>
  }
  
  /**
   * Verify that a single named instance model is correctly identifiable composed of owningDefinition/ElementLocation/Identity.
   * 
   * 
   * @param definition the definition of 
   * @param errorListener accepts and displays all errors produced by analyzing the models.
   * @return returns a map of each instance name to the single model that the has been resolved to. 
   */
  private Map&lt;String, InstanceModel&gt; ensureSingleInstanceOfEachName(DefinitionModel definition,
      Consumer&lt;ErrorModel&gt; errorListener) {
<span class="fc" id="L227">    Map&lt;String, Map&lt;String, InstanceModel&gt;&gt; instancesByNameAndLocationDedupped = </span>
<span class="fc" id="L228">        definitionToAllInstancesByNameAndSourceLocation(definition);</span>
    
<span class="fc" id="L230">    final Map&lt;String, InstanceModel&gt; resolvedDependencies = new HashMap&lt;&gt;();</span>
<span class="fc" id="L231">    boolean errored = false;    </span>
<span class="fc bfc" id="L232" title="All 2 branches covered.">    for (Entry&lt;String, Map&lt;String, InstanceModel&gt;&gt; entry : instancesByNameAndLocationDedupped.entrySet()) {</span>
<span class="fc bfc" id="L233" title="All 2 branches covered.">      if (entry.getValue().size() == 1) {</span>
<span class="fc" id="L234">        resolvedDependencies.put(entry.getKey(), entry.getValue().values().iterator().next()); //get only InstanceModel.</span>
      } else {
<span class="fc" id="L236">        errored = true;</span>
<span class="fc" id="L237">        errorListener.accept(errorForDuplicateInstanceModels(definition, entry.getValue().values().stream()</span>
<span class="fc" id="L238">            .sorted((i1, i2) -&gt; i1.getElementLocation().compareTo(i2.getElementLocation()))</span>
<span class="fc" id="L239">            .collect(Collectors.toList())));</span>
      }
<span class="fc" id="L241">    }</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">    return errored ? null : resolvedDependencies;</span>
  }
  
  /**
   * Give a definition model, extract all instances from this definition, and all imported definitions.
   * Group the instances by name, and then map them from source location to InstanceModel.
   *  
   * @param definition model to extract all instance information from, including imported definitions.
   * @return a map of maps, [name -&gt; [sourceLocation -&gt; instanceModel]]
   */
  private Map&lt;String, Map&lt;String, InstanceModel&gt;&gt; definitionToAllInstancesByNameAndSourceLocation(
      DefinitionModel definition) {
    //create a stream of all imported Definition's InstanceModels
<span class="fc" id="L255">    Stream&lt;InstanceModel&gt; imported = definition.getDependencies().stream()</span>
<span class="fc" id="L256">        .map(d -&gt; d.getProvidedInstances()).flatMap(x -&gt; x.stream());</span>
    //merge the stream with all local instance models.
<span class="fc" id="L258">    Stream&lt;InstanceModel&gt; instanceModelStream = Stream.concat(definition.getObjectDefinitions().stream(), imported);</span>

    //map all instances by name and then by source location (due to diamond dependencies in definition imports.
<span class="fc" id="L261">    Map&lt;String, Map&lt;String, InstanceModel&gt;&gt; instancesByNameAndLocationDedupped = instanceModelStream</span>
<span class="fc" id="L262">        .flatMap(instance -&gt; getEntryListForNameAndAlias(instance).stream()) //flat map all alias to entries</span>
<span class="fc" id="L263">        .collect(Collectors.groupingBy(entry -&gt; entry.getKey(), //group by name</span>
<span class="fc" id="L264">            Collectors.mapping(entry -&gt; entry.getValue(), </span>
<span class="fc" id="L265">                Collectors.toMap(im -&gt; im.getElementLocation(), //by location</span>
<span class="fc" id="L266">                    im -&gt; im, //identity function for first insert</span>
                    //choose the one with source element on merge, if any
<span class="nc bnc" id="L268" title="All 2 branches missed.">                    (im1, im2) -&gt; im1.getSourceElement().isPresent() ? im1 : im2))));</span>
<span class="fc" id="L269">    return instancesByNameAndLocationDedupped;</span>
  }

  /**
   * Given a list of duplicate instance models (same identifier, different source elements) produce a 
   * well formed ErrorModel.
   * 
   * @param definition where the error was first detected.
   * @param causes the list of all instances models from the definition or any of it's imported definitions.
   * @return an well formed ErrorModel of the duplicated beans.
   */
  private ErrorModel errorForDuplicateInstanceModels(DefinitionModel definition, List&lt;InstanceModel&gt; causes) {
<span class="fc" id="L281">    ArrayList&lt;AbstractModel&gt; involved = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L282">    involved.add(definition);</span>
<span class="fc" id="L283">    involved.addAll(causes.stream()</span>
<span class="fc" id="L284">        .filter(instanceModel -&gt; instanceModel.getSourceElement().isPresent())</span>
<span class="fc" id="L285">        .collect(Collectors.toList()));</span>
<span class="fc" id="L286">    return new ErrorModel(ErrorType.DUPLICATE_OBJECT_DEFINITIONS, causes, involved);</span>
  }
  
  /**
   * Inspects the instance graph for cycles, any cycle is printed as an error.   The nameToEntity parameter doesn't list expected
   * instances, any instances that are not found in the nameToInstances map (they are looked for because they are referenced as a
   * dependency by an instance in the map) and are not found by name in the definition's expectedInstances are treated as errors
   * as well.
   * 
   * @param definition definition being processed.  Will uses it's expected list, any instances references as dependencies but
   *     not found, not listed as expected in this DefinitionModel, will be treated as errors.
   * @param nameToEntity name to unique instanceModels, verified before call.
   * @param errorListener accepts and displays all errors produced by analyzing the models
   * @return true if an error occurred, false otherwise
   */
  private boolean detectCyclesInEntityGraph(final DefinitionModel definition, final Map&lt;String, InstanceModel&gt; nameToEntity,
      final Consumer&lt;ErrorModel&gt; errorListener) {
<span class="fc" id="L303">    final Map&lt;String, ExpectedModel&gt; missing = new HashMap&lt;&gt;();</span>
<span class="fc" id="L304">    final Graph&lt;BaseInstanceModel, DefaultEdge&gt; entityGraph = new DefaultDirectedGraph&lt;&gt;(DefaultEdge.class);</span>
<span class="fc bfc" id="L305" title="All 2 branches covered.">    for (BaseInstanceModel entity : nameToEntity.values()) {</span>
<span class="fc bfc" id="L306" title="All 2 branches covered.">      if (!entityGraph.containsVertex(entity)) {</span>
<span class="fc" id="L307">        entityGraph.addVertex(entity);</span>
      }
<span class="pc bpc" id="L309" title="1 of 2 branches missed.">      if (InstanceModel.class.isAssignableFrom(entity.getClass())) {</span>
<span class="fc" id="L310">        InstanceModel instanceModel = (InstanceModel) entity;</span>
<span class="fc bfc" id="L311" title="All 2 branches covered.">        for (InstanceDependencyModel instanceDependency : instanceModel.getDependencies()) {</span>
<span class="fc" id="L312">          BaseInstanceModel dependency = nameToEntity.get(instanceDependency.getIdentity());</span>
<span class="fc bfc" id="L313" title="All 2 branches covered.">          if (dependency == null) {</span>
<span class="fc" id="L314">            dependency = missing.computeIfAbsent(instanceDependency.getIdentity(), s -&gt; new ExpectedModel(s));</span>
<span class="fc" id="L315">            missing.get(instanceDependency.getIdentity())</span>
<span class="fc" id="L316">              .addDefinitionReferenceToType(instanceModel.getIdentity(), instanceDependency.getType());</span>
          }
<span class="fc bfc" id="L318" title="All 2 branches covered.">          if (!entityGraph.containsVertex(dependency)) {</span>
<span class="fc" id="L319">            entityGraph.addVertex(dependency);</span>
          }
<span class="fc" id="L321">          entityGraph.addEdge(entity, dependency);</span>
<span class="fc" id="L322">        }</span>
      }
<span class="fc" id="L324">    }</span>
    
<span class="fc" id="L326">    boolean errored = errorsForCycles(errorListener, entityGraph);</span>
<span class="fc bfc" id="L327" title="All 4 branches covered.">    errored = testAllMissingEntitiesAreExpected(definition, errorListener, missing, entityGraph) || errored;</span>
<span class="fc bfc" id="L328" title="All 4 branches covered.">    errored = errorUnusedExpectedsOnDefinition(definition, errorListener, missing) || errored;</span>
<span class="fc" id="L329">    return errored;</span>
  }

  private boolean checkInstancesTypesInDefinition(final DefinitionModel definition, final Map&lt;String, InstanceModel&gt; nameToEntity,
      final Consumer&lt;ErrorModel&gt; errorListner, AssignabilityUtils assignabilityUtils) {
<span class="fc" id="L334">    boolean errored = false;</span>
<span class="fc" id="L335">    List&lt;InstanceModel&gt; instances = definition.getObjectDefinitions();</span>
<span class="fc bfc" id="L336" title="All 2 branches covered.">    for (InstanceModel instance : instances) {</span>
<span class="fc bfc" id="L337" title="All 2 branches covered.">      for (InstanceDependencyModel instanceDependency : instance.getDependencies()) {</span>
<span class="fc" id="L338">        InstanceModel dependency = nameToEntity.get(instanceDependency.getIdentity());</span>
<span class="fc bfc" id="L339" title="All 4 branches covered.">        if (dependency != null &amp;&amp; !assignabilityUtils.isAssignableFrom(dependency, instance)) {</span>
<span class="fc" id="L340">          errored = true;</span>
<span class="fc" id="L341">          errorListner.accept(new ErrorModel(ErrorType.UNMATCHED_TYPES,</span>
<span class="fc" id="L342">              Arrays.asList(instance, dependency), Arrays.asList(instance, dependency)));</span>
        }
<span class="fc" id="L344">      }</span>
<span class="fc" id="L345">    }</span>
<span class="fc" id="L346">    return errored;</span>
  }

  private boolean errorUnusedExpectedsOnDefinition(final DefinitionModel definition, final Consumer&lt;ErrorModel&gt; errorListner,
      final Map&lt;String, ExpectedModel&gt; missing) {
<span class="fc" id="L351">    boolean errored = false;</span>
<span class="fc bfc" id="L352" title="All 2 branches covered.">    for (ExpectedModel expected : definition.getExpectedDefinitions()) {</span>
<span class="fc bfc" id="L353" title="All 2 branches covered.">      if (!missing.keySet().contains(expected.getIdentity())) {</span>
<span class="fc" id="L354">        errorListner.accept(new ErrorModel(ErrorType.UNUSED_EXPECTED, Arrays.asList(expected), Arrays.asList(definition)));</span>
<span class="fc" id="L355">        errored = true;</span>
      }
<span class="fc" id="L357">    }</span>
<span class="fc" id="L358">    return errored;</span>
  }

  private boolean errorsForCycles(final Consumer&lt;ErrorModel&gt; errorListner,
      final Graph&lt;BaseInstanceModel, DefaultEdge&gt; entityGraph) {
<span class="fc" id="L363">    SzwarcfiterLauerSimpleCycles&lt;BaseInstanceModel, DefaultEdge&gt; cycleFind = new SzwarcfiterLauerSimpleCycles&lt;&gt;();</span>
<span class="fc" id="L364">    boolean errored = false;</span>
<span class="fc" id="L365">    cycleFind.setGraph(entityGraph);</span>
<span class="fc" id="L366">    List&lt;List&lt;BaseInstanceModel&gt;&gt; cycles = cycleFind.findSimpleCycles();</span>
<span class="fc bfc" id="L367" title="All 2 branches covered.">    for (List&lt;BaseInstanceModel&gt; cycle : cycles) {</span>
<span class="fc" id="L368">      errored = true;</span>
<span class="fc" id="L369">      errorListner.accept(new ErrorModel(ErrorType.CYCLE_IN_DEFINITION_SOURCES, cycle, cycle));</span>
<span class="fc" id="L370">    }</span>
<span class="fc" id="L371">    return errored;</span>
  }

  private boolean testAllMissingEntitiesAreExpected(final DefinitionModel definition, final Consumer&lt;ErrorModel&gt; errorListner,
      final Map&lt;String, ExpectedModel&gt; missing, final Graph&lt;BaseInstanceModel, DefaultEdge&gt; entityGraph) {
    //check computed expected are actually expected
<span class="fc" id="L377">    boolean errored = false;</span>
<span class="fc" id="L378">    List&lt;String&gt; expectedMissing = definition.getExpectedDefinitions().stream().map(em -&gt; em.getIdentity())</span>
<span class="fc" id="L379">        .collect(Collectors.toList());</span>
<span class="fc bfc" id="L380" title="All 2 branches covered.">    for (ExpectedModel expected : missing.values()) {</span>
<span class="fc bfc" id="L381" title="All 2 branches covered.">      if (!expectedMissing.contains(expected.getIdentity())) {</span>
<span class="fc" id="L382">        List&lt;AbstractModel&gt; dependsOnMissing = Stream.concat(</span>
<span class="fc" id="L383">            Stream.of(definition), </span>
<span class="fc" id="L384">            entityGraph.incomingEdgesOf(expected).stream().map(edge -&gt; entityGraph.getEdgeSource(edge))</span>
<span class="fc" id="L385">              .filter(m -&gt; m.getSourceElement().isPresent()))</span>
<span class="fc" id="L386">            .collect(Collectors.toList());</span>
<span class="fc" id="L387">        errored = true;</span>
<span class="fc" id="L388">        errorListner.accept(new ErrorModel(ErrorType.MISSING_BEAN_DEFINITIONS, Arrays.asList(expected), dependsOnMissing));</span>
<span class="fc" id="L389">      } else {</span>
<span class="fc" id="L390">        definition.addComputedExpected(expected);</span>
      }
<span class="fc" id="L392">    }</span>
<span class="fc" id="L393">    return errored;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>