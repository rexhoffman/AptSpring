<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>AnnotationValueExtractor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">AptSpringProcessor</a> &gt; <a href="index.source.html" class="el_package">com.salesforce.aptspring.processor</a> &gt; <span class="el_source">AnnotationValueExtractor.java</span></div><h1>AnnotationValueExtractor.java</h1><pre class="source lang-java linenums">/*
 * Copyright Â© 2017, Salesforce.com, Inc
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the &lt;organization&gt; nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot; AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL &lt;COPYRIGHT HOLDER&gt; BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */
package com.salesforce.aptspring.processor;

import java.util.ArrayList;
import java.util.List;
import java.util.Map.Entry;

import javax.lang.model.element.AnnotationMirror;
import javax.lang.model.element.AnnotationValue;
import javax.lang.model.element.Element;
import javax.lang.model.element.ExecutableElement;
import javax.lang.model.element.TypeElement;
import javax.lang.model.element.VariableElement;
import javax.lang.model.util.SimpleAnnotationValueVisitor8;

<span class="nc" id="L41">public class AnnotationValueExtractor {</span>

  private static final String ALIAS_TYPE = &quot;org.springframework.core.annotation.AliasFor&quot;;
  
  private static final String ALIAS_TARGET_TYPE = &quot;annotation&quot;;

  private static final String ALIAS_TARGET_FIELD = &quot;attribute&quot;;
  
  private static final String DEFAULT_ANNOTATION_VALUE = &quot;value&quot;;

  
<span class="fc" id="L52">  private static class AliasData {</span>
<span class="fc" id="L53">    private String targetAnnotation = null;</span>
<span class="fc" id="L54">    private String targetField = null;</span>
  }
  
  /**
   * Utility method to extract the value of annotation on a class.
   * Hooks to honor spring's AliasFor annotation, see {@link AnnotationValueExtractor#ALIAS_TYPE}.
   * 
   * @param e the element to inspect
   * @param annotationTypeName the fully qualified name of the annotation class.
   * @param methodName the name of the annotation value
   * @return an array of Strings representing the value of annotation parameter or it's alias.
   *     null if the annotation is not present (or is in a wrapper annotation as an array of values),
   *     an empty array is returned if the annotation is present, but the method does not exist.
   */
  public static String[] getAnnotationValue(Element e, String annotationTypeName, String methodName) {
<span class="fc bfc" id="L69" title="All 2 branches covered.">    if (e instanceof TypeElement) {</span>
      //TODO: do recursive call in to 
<span class="fc" id="L71">      ((TypeElement) e).getSuperclass();</span>
<span class="fc" id="L72">      ((TypeElement) e).getInterfaces();</span>
    }
<span class="fc bfc" id="L74" title="All 2 branches covered.">    for (AnnotationMirror a : e.getAnnotationMirrors()) {</span>
<span class="fc" id="L75">      String[] returned = getAnnotationValue(a, annotationTypeName, methodName);</span>
<span class="fc bfc" id="L76" title="All 2 branches covered.">      if (returned != null) {</span>
<span class="fc" id="L77">        return returned;</span>
      }
<span class="fc" id="L79">    }</span>
<span class="fc" id="L80">    return null;</span>
  }
  
  /**
   * Any empty array will be returned as long as the annotation is found (regardless of whether the value is set or not).
   * A null value is returned if the (meta) annotation is not found. Currently only supports one level of indirection through
   * spring's AliasFor, meaning that an alias of another field will work, but not an alias of an alias.   TODO: This could be corrected 
   * with an algorithm for extracting all the values off of Annotations in to another, cached, data set, but doesn't currently
   * appear to be needed for standard spring annotations - user annotations may trip up on this.
   *
   * @param am the annotation to parse for a value.
   * @param annotationTypeName the type of the annotation we are interested in, necessary for meta-annotation processing.
   * @param methodName the name of the parameter designating the value 
   * @return if the annotation or meta annotation is found, the AnnotationValues are converted to strings by 
   *    {@link AnnotationValueExtractor} and returned in an array.  
   */
  private static String[] getAnnotationValue(AnnotationMirror am, String annotationTypeName, String methodName) {
<span class="fc" id="L97">    String currentType = am.getAnnotationType().toString();</span>
<span class="fc bfc" id="L98" title="All 2 branches covered.">    for (Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; ev : am.getElementValues().entrySet()) {</span>
<span class="fc" id="L99">      boolean aliasMatch = aliasMatch(getAlias(ev.getKey()), annotationTypeName, methodName, currentType);</span>
<span class="fc" id="L100">      boolean foundField = ev.getKey().getSimpleName().toString().equals(methodName);</span>
<span class="fc bfc" id="L101" title="All 6 branches covered.">      if (aliasMatch || (foundField &amp;&amp; currentType.equals(annotationTypeName))) {</span>
<span class="fc" id="L102">        AnnotationValueExtractorVisitor ex = new AnnotationValueExtractorVisitor();</span>
<span class="fc" id="L103">        List&lt;String&gt; values = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L104">        ex.visit(ev.getValue(), values);</span>
<span class="fc" id="L105">        return values.toArray(new String[values.size()]); </span>
      }
<span class="fc" id="L107">    }</span>
<span class="fc bfc" id="L108" title="All 2 branches covered.">    if (currentType.equals(annotationTypeName)) {</span>
      //no field matched
<span class="fc" id="L110">      return new String[]{};</span>
    }
    
<span class="pc bpc" id="L113" title="1 of 2 branches missed.">    for (AnnotationMirror a : am.getAnnotationType().getAnnotationMirrors()) {</span>
      //cachable here...
<span class="nc bnc" id="L115" title="All 2 branches missed.">      if (!a.getAnnotationType().asElement().toString().startsWith(&quot;java.lang.annotation&quot;)) {</span>
<span class="nc" id="L116">        String[] output = getAnnotationValue(a, annotationTypeName, methodName);</span>
<span class="nc bnc" id="L117" title="All 2 branches missed.">        if (output != null) {</span>
<span class="nc" id="L118">          return output;</span>
        }
      }
<span class="nc" id="L121">    }</span>
<span class="fc" id="L122">    return null;</span>
  }

  /**
   * On an executable element (that is a value holder on annotation) extract any direct uses of @AlaisFor. 
   * Meaning that an alias of another field will work, but not an alias of an alias.   TODO: This could be corrected 
   * with an algorithm for extracting all the values off of Annotations in to another, cached, data set, but doesn't currently
   * appear to be needed for standard spring annotations - user annotations may trip up on this.
   * 
   * @param annotationParameter the annotation's parameter to inspect for uses of @AliasFor
   * @return an AliasData if the the annotation is found, null otherwise.
   */
  private static AliasData getAlias(ExecutableElement annotationParameter) {
<span class="fc" id="L135">    AliasData output = null;</span>
<span class="fc bfc" id="L136" title="All 2 branches covered.">    for (AnnotationMirror am : annotationParameter.getAnnotationMirrors()) {</span>
<span class="pc bpc" id="L137" title="1 of 2 branches missed.">      if (ALIAS_TYPE.equals(am.getAnnotationType().asElement().toString())) {</span>
<span class="fc" id="L138">        output = new AliasData();</span>
<span class="fc bfc" id="L139" title="All 2 branches covered.">        for (Entry&lt;? extends ExecutableElement, ? extends AnnotationValue&gt; ev : am.getElementValues().entrySet()) {</span>
<span class="fc" id="L140">          String fieldName = ev.getKey().getSimpleName().toString();</span>
<span class="fc" id="L141">          AnnotationValue av = ev.getValue();</span>
<span class="fc bfc" id="L142" title="All 2 branches covered.">          if (ALIAS_TARGET_TYPE.equals(fieldName)) {</span>
<span class="fc" id="L143">            output.targetAnnotation = getAttributeValueFromAnnotationFieldAsString(av, false);</span>
          }
          //AliasFor has both &quot;value&quot; and &quot;attribute&quot; to specify the target
          //annotation field, however, neither may be set which means that the
          //the same name as the current annotation's field which is annotated
          //with AliasFor will be used.
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">          if (ALIAS_TARGET_FIELD.equals(fieldName)) {</span>
<span class="nc" id="L150">            output.targetField = getAttributeValueFromAnnotationFieldAsString(av, true);</span>
          }
<span class="pc bpc" id="L152" title="1 of 4 branches missed.">          if (DEFAULT_ANNOTATION_VALUE.equals(fieldName) &amp;&amp; output.targetField == null) {</span>
<span class="fc" id="L153">            output.targetField = getAttributeValueFromAnnotationFieldAsString(av, true);</span>
          }
<span class="fc" id="L155">        }</span>
        //if the fieldName isn't declared by either &quot;value&quot; or &quot;attribute&quot;
        //assume that the existing field's name is it's value.
        //hmm.... not good enough this may be a meta-annotation for a canonical annotation.
<span class="fc bfc" id="L159" title="All 4 branches covered.">        if (output.targetAnnotation != null &amp;&amp; output.targetField == null) {</span>
<span class="fc" id="L160">          output.targetField = annotationParameter.getSimpleName().toString();</span>
        }
      }
<span class="fc" id="L163">    }</span>
<span class="fc" id="L164">    return output;</span>
  }
  
  /**
   * Given an annotationValue (a field on an Annotation) extract the string representation of
   * it's single value (not for nested annotations as a value in an annotation).
   * 
   * @param av The annotation value to extract
   * @param emptyStringAsNull if the return value would be an empty string instead return null;
   * @return the string representation of the annotation or null;
   */
  private static String getAttributeValueFromAnnotationFieldAsString(AnnotationValue av, boolean emptyStringAsNull) {
<span class="pc bpc" id="L176" title="2 of 4 branches missed.">    if (av != null &amp;&amp; av.getValue() != null) {</span>
<span class="pc bpc" id="L177" title="3 of 4 branches missed.">      return av.getValue().toString().isEmpty() &amp;&amp; emptyStringAsNull ? null : av.getValue().toString();</span>
    } else { 
<span class="nc" id="L179">      return null;</span>
    }
  }
  
  /**
   *  Checks to see if the aliasData matches the targetType and targetField.   The aliasData may have a null
   *  targetType and if so, the currentAnnotation is used to determine if the targetType Matches.
   *  This indicates that the AliasFor annotation is on an element in the targetType annotation itself.
   */
  private static boolean aliasMatch(AliasData aliasData, String targetType, String targetField, String currentAnnotation) {
<span class="fc bfc" id="L189" title="All 2 branches covered.">    if (aliasData == null) {</span>
<span class="fc" id="L190">      return false;</span>
    }
<span class="fc" id="L192">    return (//types match</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">        (targetType.equals(aliasData.targetAnnotation)</span>
<span class="fc bfc" id="L194" title="All 4 branches covered.">        || (aliasData.targetAnnotation == null &amp;&amp; targetType.equals(currentAnnotation)))</span>
        &amp;&amp; //fields match
<span class="fc bfc" id="L196" title="All 2 branches covered.">        targetField.equals(aliasData.targetField));</span>
  }
  
  private static class AnnotationValueExtractorVisitor extends SimpleAnnotationValueVisitor8&lt;Void, List&lt;String&gt;&gt; {

    @Override
    protected Void defaultAction(Object o, List&lt;String&gt; values) {
<span class="fc" id="L203">      values.add(o.toString());</span>
<span class="fc" id="L204">      return null;</span>
    }

    public Void visitEnumConstant(VariableElement c, List&lt;String&gt; values) {
<span class="nc" id="L208">      values.add(c.getSimpleName().toString());</span>
<span class="nc" id="L209">      return null;</span>
    }

    public Void visitAnnotation(AnnotationMirror a, List&lt;String&gt; values) {
      // should probably do something here, but what? return annotation types?
<span class="nc" id="L214">      return defaultAction(a, values);</span>
    }

    public Void visitArray(List&lt;? extends AnnotationValue&gt; vals, List&lt;String&gt; values) {
<span class="fc bfc" id="L218" title="All 2 branches covered.">      for (AnnotationValue val : vals) {</span>
<span class="fc" id="L219">        visit(val, values);</span>
<span class="fc" id="L220">      }</span>
<span class="fc" id="L221">      return null;</span>
    }
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>